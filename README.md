# ThirdWayV Challenge 

The main goal of this task is to retrieve a product list and show it as a list, with option to show product details in a separate view.  

# Application Architecture  
MVVM-Coordinators used as a main architecture for this application 
MVVM stands for  **Model-View-ViewModel**. At a high level:

1.  **Models**  are raw data objects, such as managed CoreData objects or even value-type objects stored in UserDefaults.  
    
2.  **Views**  consist of UIViewController and UIView objects when using UIKit, or structs that conform to the aptly-named View protocol in SwiftUI. The View layer constitutes everything that the user sees and interacts with.  
    
3.  **ViewModels**  encapsulate all business logic for their corresponding Views. They handle events generated by user interaction in the View layer by performing network calls, creating side effects, and updating the Model layer. Each ViewModel is owned by some View in a unidirectional manner.

By adding a new layer, Coordinator  enforce Separation of concerns by attach routing from view to this layer

## Goals of our Architecture

So what does all this extra complexity aim to accomplish? Our architecture has three main goals:

1.  üëê  **Separation of concerns**  
    Logic is separated into four main areas:  
    -   **Reading and writing of Models.**  All interaction with underlying data models must go through the Service layer. Services provide another layer of abstraction between ViewModels and Models by fa√ßading asynchronous network calls/database interactions and managed objects behind Observables and value-type structs.  
        
    -   **Business logic**. When they are initialized, ViewModels are injected with Services and data from the previous ViewModel. They can then be called as a pure function which takes in View-generated inputs (view lifecycle events, button taps, etc.) and outputs a set of callbacks and Observables which drive the View as a function of state.  
        
    -   **View setup**. UIViewControllers and UIViews are solely responsible for configuring their appearance, passing input events to their ViewModels, and binding to the returned outputs.  
        
    -   **Routing**. Getting things on and off the screen is solely the job of the Coordinator.  
        

2.  üí™  **Testability**  
    By isolating business logic in the ViewModel layer and interaction with Models to the Service layer, we can test our ViewModels by injecting them with Mock Services that provide known inputs and assert expected outputs.

3.  ü§ù  **Elimination of shared mutable state**  
    While the binding of the View and ViewModel could be accomplished using the protocol-delegate pattern or another imperative means, this often leads to code that is difficult to understand. It also usually requires the ViewModel to maintain state that the View accesses or  _mutates_  (*shudder*). This is a common source of bugs, as it‚Äôs difficult to reason about when state changes occur and whether or not everyone interested in those changes has been notified.  
      
    The purpose of using Combine is to replace shared mutable state with immutable and declarative streams. This isolates where state changes can occur to the declaration of the stream, and forces objects interested in state changes to explicitly subscribe to them.
    
